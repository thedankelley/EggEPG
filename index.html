<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IPTV M3U Editor — Sort, Logo Grabber, Xtream Converter (Client-side)</title>

<style>
  :root{--bg:#f7f9fb;--card:#fff;--accent:#0b79d0;--muted:#556;--ok:#1b9e5f}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); margin:0;padding:20px;color:#0b1722;}
  .wrap{max-width:1100px;margin:0 auto}
  header{display:flex;justify-content:space-between;align-items:center;gap:10px}
  h1{font-size:20px;margin:0}
  .row{display:flex;gap:12px;align-items:flex-start}
  .card{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(8,28,56,0.06)}
  .panel{flex:1;min-width:260px}
  .panel.small{flex:0 0 340px}
  input[type=text], input[type=url], textarea, select {width:100%;padding:8px;border-radius:8px;border:1px solid #e2e8f0;box-sizing:border-box}
  button{background:var(--accent);color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
  button.ghost{background:transparent;color:var(--accent);border:1px solid #dbeafe}
  .muted{color:var(--muted);font-size:13px}
  .filelist{max-height:340px;overflow:auto;margin-top:8px;border-radius:8px;border:1px dashed #e6eef9;padding:8px;background:linear-gradient(180deg,#fff,#fbfdff)}
  .chan{display:flex;align-items:center;gap:10px;padding:8px;border-bottom:1px solid #f1f5f9}
  .chan:last-child{border-bottom:0}
  .chan img{width:56px;height:32px;object-fit:contain;background:#fff;border-radius:4px;border:1px solid #eef4fb}
  .chan .meta{flex:1;min-width:0}
  .chan .meta b{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .drag-hint{cursor:grab}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .smallbtn{padding:6px 10px;font-size:13px}
  .status{font-size:13px;color:var(--muted);margin-top:8px}
  .xtreamOut{background:#0f1720;color:#fff;padding:8px;border-radius:6px;font-family:monospace;word-break:break-all}
  .logo-input{display:flex;gap:6px;align-items:center}
  .logo-input input{flex:1}
  .logo-thumb{width:100px;height:56px;object-fit:contain;border-radius:6px;border:1px solid #eee}
  footer{margin-top:18px;text-align:center;color:var(--muted);font-size:13px}
  @media (max-width:900px){ .row{flex-direction:column} .panel.small{width:100%} }
</style>
</head>
<body>
<div class="wrap">

<header>
  <div>
    <h1>IPTV M3U Editor — Sort • Logo Grabber • Xtream Converter (Client-side)</h1>
    <div class="muted">Everything runs in your browser. Nothing is uploaded unless you choose to fetch remote XML/M3U URLs.</div>
  </div>
  <div style="text-align:right">
    <button id="downloadM3U" title="Export edited M3U">Export M3U</button>
    <button id="downloadM3UWithLogos" title="Export M3U and embed logos if present">Export M3U (with logos)</button>
  </div>
</header>

<main class="row" style="margin-top:14px">
  <section class="card panel small">
    <h3>Load / Paste M3U</h3>
    <input type="file" id="m3uFile" accept=".m3u,.txt" />
    <div class="controls">
      <button id="loadFromFile" class="smallbtn">Load file</button>
      <button id="pasteM3U" class="smallbtn ghost">Paste into editor below</button>
    </div>
    <div style="margin-top:10px">
      <label class="muted">Or paste raw M3U</label>
      <textarea id="m3uText" rows="8" placeholder="#EXTM3U..."></textarea>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="parseBtn">Parse M3U</button>
        <button id="autoLogoBtn" class="ghost">Auto-fetch logos (TVmaze)</button>
        <button id="clearBtn" class="ghost">Clear</button>
      </div>
      <div id="sourceStatus" class="status"></div>
    </div>

    <hr style="margin:12px 0">

    <h4>Xtream Codes → M3U URL</h4>
    <div class="muted">Enter your Xtream credentials (client-side only). No values are sent anywhere.</div>
    <input id="xcHost" type="url" placeholder="Host, e.g. http://example.com:8080" style="margin-top:8px" />
    <input id="xcUser" type="text" placeholder="Username" />
    <input id="xcPass" type="text" placeholder="Password" />
    <div class="controls">
      <button id="buildXtream" class="smallbtn">Generate URL</button>
      <button id="buildXtreamM3U" class="smallbtn ghost">Generate M3U Template</button>
    </div>
    <div style="margin-top:8px">
      <div class="muted">Generated URL</div>
      <div id="xtreamOutput" class="xtreamOut" style="margin-top:6px">—</div>
    </div>

  </section>

  <section class="card panel" style="flex:2">
    <h3>Channels — Drag to reorder</h3>
    <div class="muted">Drag & drop channels to change order. Click a channel to edit tvg-id / tvg-name / tvg-logo. Use "Auto-fetch logos" first to populate logos.</div>

    <div class="filelist" id="channelList" style="margin-top:10px">
      <!-- populated dynamically -->
      <div class="muted">No channels loaded yet — parse an M3U to see channels here.</div>
    </div>

    <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
      <button id="removeDup" class="smallbtn">Remove Duplicates</button>
      <button id="sortAlphabet" class="smallbtn ghost">Sort A→Z</button>
      <button id="sortReverse" class="smallbtn ghost">Sort Z→A</button>
      <button id="saveOrder" class="smallbtn">Save Order (to editor)</button>
      <div style="flex:1"></div>
      <div class="muted">Channels: <span id="chanCount">0</span></div>
    </div>

    <hr style="margin:12px 0">

    <h4>Editor</h4>
    <div class="muted">You can directly edit the M3U text here and re-parse. When exporting, the current channel order and any updated tvg-* attributes will be used.</div>
    <textarea id="m3uEditor" rows="8" style="margin-top:8px"></textarea>

  </section>
</main>

<footer>
  <div class="muted" style="margin-top:8px">Client-only app • Use GitHub Pages to host this file as index.html</div>
</footer>

<script>
/*
  IPTV M3U Editor — client-side
  Features implemented:
    - Parse M3U (EXTINF lines + streams)
    - Show channel list with logos and metadata
    - Drag & drop sorting
    - Remove duplicates and sort operations
    - Auto-fetch logos:
        * If tvg-logo present, show it
        * Else try TVmaze search: https://api.tvmaze.com/search/shows?q=channelName
          (uses show.image or show.network.image if present)
        * Note: remote fetches may fail due to CORS on some hosts
    - Xtream converter: host/user/pass -> m3u URL and a ready-to-use M3U template
    - Export M3U (current order + updated attributes)
    - All local to browser
*/

(() => {
  // State
  let channels = []; // {name, url, tvgId, tvgName, tvgLogo, rawExtinf, rawUrl}
  const channelListEl = document.getElementById('channelList');
  const m3uEditor = document.getElementById('m3uEditor');
  const m3uTextArea = document.getElementById('m3uText');
  const sourceStatus = document.getElementById('sourceStatus');
  const chanCountEl = document.getElementById('chanCount');

  // helpers
  function uid() { return 'c_' + Math.random().toString(36).slice(2,9); }

  function setStatus(s) { sourceStatus.textContent = s; }

  // Parse M3U text into channels[]
  function parseM3U(text) {
    channels = [];
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(s => s.length > 0);
    let currentMeta = null;
    for (const line of lines) {
      if (line.startsWith('#EXTINF')) {
        currentMeta = line;
      } else if (line.startsWith('#')) {
        // ignore other comments
      } else {
        // url line
        const url = line;
        if (!currentMeta) {
          // no meta, create a minimal entry
          channels.push({ id: uid(), name: url, url, tvgId:'', tvgName:'', tvgLogo:'', rawExtinf:'', rawUrl:url });
        } else {
          const ext = currentMeta;
          // parse tvg-id, tvg-name, tvg-logo attributes if present
          const tvgIdMatch = ext.match(/tvg-id="([^"]*)"/i);
          const tvgNameMatch = ext.match(/tvg-name="([^"]*)"/i);
          const tvgLogoMatch = ext.match(/tvg-logo="([^"]*)"/i);
          // fallback name: after comma
          const afterComma = ext.indexOf(',') >= 0 ? ext.split(',').slice(1).join(',').trim() : '';
          const name = tvgNameMatch ? tvgNameMatch[1] : (afterComma || url);
          const tvgId = tvgIdMatch ? tvgIdMatch[1] : '';
          const tvgLogo = tvgLogoMatch ? tvgLogoMatch[1] : '';
          channels.push({ id: uid(), name, url, tvgId, tvgName: name, tvgLogo, rawExtinf: ext, rawUrl: url });
          currentMeta = null;
        }
      }
    }
    renderChannelList();
  }

  // Render channel list
  function renderChannelList() {
    channelListEl.innerHTML = '';
    if (channels.length === 0) {
      channelListEl.innerHTML = '<div class="muted">No channels loaded — parse an M3U first.</div>';
      chanCountEl.textContent = '0';
      return;
    }
    for (let i = 0; i < channels.length; i++) {
      const ch = channels[i];
      const row = document.createElement('div');
      row.className = 'chan';
      row.draggable = true;
      row.dataset.index = i;
      row.innerHTML = `
        <div style="width:72px;display:flex;align-items:center;justify-content:center">
          <img class="logoThumb" src="${escapeHtml(ch.tvgLogo||'')}" alt="" onerror="this.style.visibility='hidden'">
        </div>
        <div class="meta">
          <b title="${escapeHtml(ch.name)}">${escapeHtml(ch.name)}</b>
          <div class="muted">tvg-id: <span class="muted idText">${escapeHtml(ch.tvgId||'')}</span></div>
          <div class="muted">url: <span class="muted urlText">${escapeHtml(simplifyUrl(ch.url))}</span></div>
        </div>
        <div style="display:flex;gap:6px;align-items:center">
          <button class="smallbtn editBtn">Edit</button>
          <button class="smallbtn logoBtn ghost">Set Logo</button>
          <button class="smallbtn hideBtn ghost">Hide</button>
        </div>
      `;
      // drag events
      row.addEventListener('dragstart', (ev) => {
        ev.dataTransfer.setData('text/plain', ev.currentTarget.dataset.index);
        ev.currentTarget.style.opacity = '0.6';
      });
      row.addEventListener('dragend', (ev) => {
        ev.currentTarget.style.opacity = '';
      });
      row.addEventListener('dragover', (ev) => { ev.preventDefault(); ev.dataTransfer.dropEffect = 'move'; });
      row.addEventListener('drop', (ev) => {
        ev.preventDefault();
        const fromIdx = Number(ev.dataTransfer.getData('text/plain'));
        const toIdx = Number(ev.currentTarget.dataset.index);
        reorderChannels(fromIdx, toIdx);
      });

      // buttons
      row.querySelector('.editBtn').addEventListener('click', () => {
        editChannel(ch);
      });
      row.querySelector('.logoBtn').addEventListener('click', () => {
        promptSetLogo(ch);
      });
      row.querySelector('.hideBtn').addEventListener('click', () => {
        // mark hidden: remove from list but keep in memory
        channels.splice(i,1);
        renderChannelList();
      });

      channelListEl.appendChild(row);
    }
    chanCountEl.textContent = String(channels.length);
    // sync editor text to reflect updated order
    syncEditorFromChannels();
  }

  function simplifyUrl(u) {
    try {
      const url = new URL(u);
      return url.hostname + (url.pathname || '');
    } catch(e) { return u.length > 60 ? u.slice(0,60) + '…' : u; }
  }

  // reorder channels
  function reorderChannels(from, to) {
    if (from === to) return;
    const item = channels.splice(from,1)[0];
    channels.splice(to,0,item);
    renderChannelList();
  }

  // edit channel metadata
  function editChannel(ch) {
    const newName = prompt('Channel name (tvg-name):', ch.name) || ch.name;
    const newId = prompt('tvg-id:', ch.tvgId || '') || ch.tvgId;
    const newLogo = prompt('tvg-logo (URL):', ch.tvgLogo || '') || ch.tvgLogo;
    ch.name = newName;
    ch.tvgName = newName;
    ch.tvgId = newId;
    ch.tvgLogo = newLogo;
    renderChannelList();
  }

  function promptSetLogo(ch) {
    const url = prompt('Enter logo image URL (or leave blank to remove):', ch.tvgLogo || '');
    if (url === null) return;
    ch.tvgLogo = url.trim();
    renderChannelList();
  }

  // Remove duplicates (based on name+url)
  function removeDuplicates() {
    const seen = new Set();
    const out = [];
    for (const ch of channels) {
      const key = (ch.name + '|' + ch.url).toLowerCase();
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(ch);
    }
    channels = out;
    renderChannelList();
  }

  // Sort operations
  function sortAlphabet(asc=true) {
    channels.sort((a,b) => asc ? a.name.localeCompare(b.name) : b.name.localeCompare(a.name));
    renderChannelList();
  }

  // sync M3U editor from channels (rebuild M3U text using current order and attributes)
  function syncEditorFromChannels() {
    const header = '#EXTM3U\n';
    let body = '';
    for (const ch of channels) {
      const tvgIdAttr = ch.tvgId ? ` tvg-id="${escapeAttr(ch.tvgId)}"` : '';
      const tvgNameAttr = ch.tvgName ? ` tvg-name="${escapeAttr(ch.tvgName)}"` : '';
      const tvgLogoAttr = ch.tvgLogo ? ` tvg-logo="${escapeAttr(ch.tvgLogo)}"` : '';
      const ext = `#EXTINF:-1${tvgIdAttr}${tvgNameAttr}${tvgLogoAttr},${escapeLineTitle(ch.name)}`;
      body += ext + '\n' + ch.url + '\n';
    }
    m3uEditor.value = header + body;
  }

  function escapeAttr(s) {
    return s.replace(/"/g, '&quot;');
  }
  function escapeLineTitle(s) {
    return s.replace(/\n/g,' ').trim();
  }

  // parse editor into channels when user pastes edited text and clicks Parse
  function syncChannelsFromEditor() {
    const txt = m3uEditor.value.trim() || m3uTextArea.value.trim();
    if (!txt) { setStatus('No M3U text to parse'); return; }
    parseM3U(txt);
    setStatus('Parsed M3U from editor');
  }

  // Export M3U using current channels order and attributes
  function buildM3UString(includeLogos=true) {
    let out = '#EXTM3U\n';
    for (const ch of channels) {
      const idAttr = ch.tvgId ? ` tvg-id="${escapeAttr(ch.tvgId)}"` : '';
      const nameAttr = ch.tvgName ? ` tvg-name="${escapeAttr(ch.tvgName)}"` : '';
      const logoAttr = (includeLogos && ch.tvgLogo) ? ` tvg-logo="${escapeAttr(ch.tvgLogo)}"` : '';
      const ext = `#EXTINF:-1${idAttr}${nameAttr}${logoAttr},${escapeLineTitle(ch.name)}`;
      out += ext + '\n' + ch.url + '\n';
    }
    return out;
  }

  // Xtream Codes generator
  function buildXtreamUrl() {
    const host = document.getElementById('xcHost').value.trim();
    const user = document.getElementById('xcUser').value.trim();
    const pass = document.getElementById('xcPass').value.trim();
    if (!host || !user || !pass) {
      document.getElementById('xtreamOutput').textContent = 'Provide host, username and password.';
      return;
    }
    // Normalize host: ensure no trailing slash
    const h = host.endsWith('/') ? host.slice(0, -1) : host;
    // Standard Xtream URL pattern
    const url = `${h}/get.php?username=${encodeURIComponent(user)}&password=${encodeURIComponent(pass)}&type=m3u_plus&output=ts`;
    document.getElementById('xtreamOutput').textContent = url;
    return url;
  }

  // Generate a basic M3U template using Xtream credentials (just a single entry that points at the Xtream M3U)
  function buildXtreamM3UTemplate() {
    const url = buildXtreamUrl();
    if (!url) return;
    const header = '#EXTM3U\n';
    const line = `#EXTINF:-1,My Xtream Playlist\n${url}\n`;
    const out = header + line;
    document.getElementById('m3uEditor').value = out;
    setStatus('Xtream M3U template created in editor.');
    parseM3U(out); // load into channels (will have one entry)
  }

  // Auto-fetch logos: prefer existing tvgLogo; else call TVmaze search
  async function autoFetchLogos() {
    setStatus('Fetching logos... TVmaze rate-limits and CORS may affect results.');
    const tvmazeBase = 'https://api.tvmaze.com/search/shows?q='; // public, no key
    // iterate channels, but do not hammer TVmaze too fast; add small delay
    for (let i = 0; i < channels.length; i++) {
      const ch = channels[i];
      if (ch.tvgLogo) {
        // already has a logo
        continue;
      }
      // Try to derive a short query from channel name (strip punctuation)
      let q = ch.name.replace(/\(.+\)/g,'').replace(/[^a-z0-9\s]/ig,' ').trim();
      if (!q) q = ch.name;
      // Try using tvgId as fallback query
      if (!q && ch.tvgId) q = ch.tvgId;
      // Attempt TVmaze
      try {
        // Note: TVmaze supports CORS on this endpoint (commonly works). Still may be blocked occasionally.
        const resp = await fetch(tvmazeBase + encodeURIComponent(q));
        if (!resp.ok) {
          // no match or blocked
          console.warn('TVmaze failed for', q, resp.status);
          continue;
        }
        const js = await resp.json();
        if (Array.isArray(js) && js.length > 0) {
          // choose best hit (first)
          const show = js[0].show;
          // prefer show.image.original or medium; else show.network.image
          let logo = (show.image && (show.image.original || show.image.medium)) || (show.network && show.network.image && (show.network.image.original || show.network.image.medium)) || '';
          if (logo) {
            ch.tvgLogo = logo;
            console.log('Logo found for', ch.name, logo);
            // update UI immediately
            renderChannelList();
            // tiny delay to avoid rate limits
            await delay(350);
            continue;
          }
        }
      } catch (err) {
        console.warn('logo fetch error', err);
      }
      // If TVmaze didn't yield a logo, try simple guessed URL patterns (rare)
      // Example heuristics: try using https://logo.clearbit.com/<hostname> if stream URL includes hostname
      try {
        const urlObj = new URL(ch.url);
        const candidate = `https://logo.clearbit.com/${urlObj.hostname}`;
        // Ping the image HEAD to see if it exists (some CDNs may block)
        const ok = await checkImageExists(candidate);
        if (ok) { ch.tvgLogo = candidate; renderChannelList(); await delay(200); continue; }
      } catch(e){}
    }
    setStatus('Logo fetching complete (some channels may have none due to lack of data or blocked requests).');
    renderChannelList();
  }

  // helper: check image exists by fetching HEAD (or GET small)
  async function checkImageExists(url) {
    try {
      const r = await fetch(url, { method: 'HEAD' });
      return r.ok;
    } catch(e){
      // HEAD sometimes blocked; try GET with small timeout
      try {
        const r2 = await fetch(url);
        return r2.ok && r2.headers.get('content-type') && r2.headers.get('content-type').startsWith('image');
      } catch (ee) { return false; }
    }
  }

  function delay(ms) { return new Promise(res=>setTimeout(res, ms)); }

  // Utility escape for text content insertion
  function escapeHtml(s) { if(!s) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Event wiring
  document.getElementById('parseBtn').addEventListener('click', () => {
    const txt = m3uEditor.value.trim() || m3uTextArea.value.trim();
    if (!txt) { setStatus('No M3U text provided in editor or input'); return; }
    parseM3U(txt);
    setStatus('Parsed M3U');
  });

  document.getElementById('loadFromFile').addEventListener('click', () => {
    const f = document.getElementById('m3uFile').files[0];
    if (!f) { alert('Choose a file'); return; }
    const reader = new FileReader();
    reader.onload = (e) => {
      m3uEditor.value = e.target.result;
      parseM3U(e.target.result);
      setStatus('Loaded from file');
    };
    reader.readAsText(f);
  });

  document.getElementById('pasteM3U').addEventListener('click', () => {
    const txt = m3uTextArea.value.trim();
    if (!txt) { alert('Paste M3U text into the top textarea first'); return; }
    m3uEditor.value = txt;
    parseM3U(txt);
    setStatus('Pasted to editor and parsed');
  });

  document.getElementById('clearBtn').addEventListener('click', () => {
    if (!confirm('Clear current channels and editor?')) return;
    channels = [];
    m3uEditor.value = '';
    m3uTextArea.value = '';
    renderChannelList();
    setStatus('Cleared');
  });

  document.getElementById('autoLogoBtn').addEventListener('click', async () => {
    if (channels.length === 0) { setStatus('No channels to fetch logos for'); return; }
    if (!confirm('Auto-fetching logos will query TVmaze for each channel name (client-side). Continue?')) return;
    setStatus('Starting logo fetch (may take several seconds)...');
    await autoFetchLogos();
  });

  document.getElementById('removeDup').addEventListener('click', () => {
    removeDuplicates();
    setStatus('Duplicates removed');
  });

  document.getElementById('sortAlphabet').addEventListener('click', () => {
    sortAlphabet(true); setStatus('Sorted A→Z');
  });
  document.getElementById('sortReverse').addEventListener('click', () => {
    sortAlphabet(false); setStatus('Sorted Z→A');
  });

  document.getElementById('saveOrder').addEventListener('click', () => {
    syncEditorFromChannels();
    setStatus('Saved channel order to editor text.');
  });

  // downloads
  document.getElementById('downloadM3U').addEventListener('click', () => {
    const txt = buildM3UString(true);
    downloadBlob(txt, 'playlist.m3u');
  });
  document.getElementById('downloadM3UWithLogos').addEventListener('click', () => {
    const txt = buildM3UString(true);
    downloadBlob(txt, 'playlist_with_logos.m3u');
  });

  // Xtream wiring
  document.getElementById('buildXtream').addEventListener('click', () => {
    const url = buildXtreamUrl();
    if (url) {
      document.getElementById('xtreamOutput').textContent = url;
      setStatus('Xtream URL built. You can copy it.');
    }
  });
  document.getElementById('buildXtreamM3U').addEventListener('click', () => {
    buildXtreamM3UTemplate();
  });

  // utility to download text blob
  function downloadBlob(text, filename) {
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1500);
  }

  // initial sample quick help content
  m3uTextArea.placeholder = '#EXTM3U\n#EXTINF:-1,tvg-name="Channel name" tvg-id="chan1" tvg-logo="https://example.com/logo.png",Channel display name\nhttp://stream.url/stream.ts\n...';

  // expose some functions to console for advanced usage
  window._m3uEditorApp = {
    channels,
    parseM3U,
    buildM3UString,
    autoFetchLogos,
    reorderChannels,
    renderChannelList,
    syncEditorFromChannels,
    syncChannelsFromEditor: () => syncChannelsFromEditor()
  };

  // Sync initial editor to channels on load if there's content
  setTimeout(()=> {
    const initial = m3uTextArea.value.trim() || m3uEditor.value.trim();
    if (initial) parseM3U(initial);
  }, 200);

})(); // end IIFE
</script>
</body>
</html>
